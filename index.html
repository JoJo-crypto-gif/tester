<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <!-- Add viewport meta tag so that mobile devices scale correctly -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CPA MCQ Quiz</title>
    <!-- Google Fonts (Roboto) -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap"
    />
    <!-- Papa Parse -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <style>
      /* ---------------------- Global & Setup CSS ---------------------- */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      /* Prevent horizontal scrolling, ensuring containers hug the viewport edges */
      html,
      body {
        overflow-x: hidden;
      }
      body {
        font-family: "Roboto", sans-serif;
        background-color: #f9fafb;
        color: #111827;
        padding: 1px; /* default padding so that container margins remain controlled */
      }
      h2,
      h3,
      h4 {
        margin-bottom: 0.75rem;
      }
      /* SETUP page styles */
      #setup {
        background-color: #ffffff;
        border-radius: 8px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        padding: 20px;
        margin-bottom: 20px;
      }
      label {
        font-weight: 500;
        margin-right: 8px;
        margin-bottom: 4px;
        display: inline-block;
      }
      select,
      button {
        appearance: none;
        font-family: inherit;
        font-size: 0.95rem;
        padding: 8px 10px;
        margin-right: 20px;
        margin-bottom: 10px;
        border: 1px solid #d1d5db;
        border-radius: 6px;
        background-color: #ffffff;
        transition: box-shadow 0.2s;
      }
      select:focus,
      button:focus {
        outline: none;
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
      }
      #startQuizBtn {
        background-color: #3b82f6;
        color: #fff;
        border: none;
      }
      #startQuizBtn:hover {
        background-color: #2563eb;
      }
      #startQuizBtn:disabled {
        background-color: #cbd5e1;
        cursor: not-allowed;
      }
      /* ---------------------- Toggle Switch for Difficulty ---------------------- */
      .toggle-container {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
      }
      .switch {
        position: relative;
        display: inline-block;
        width: 60px;
        height: 30px;
      }
      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }
      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: 0.4s;
        border-radius: 30px;
      }
      .slider:before {
        position: absolute;
        content: "";
        height: 24px;
        width: 24px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
      }
      input:checked + .slider {
        background-color: #3b82f6;
      }
      input:checked + .slider:before {
        transform: translateX(30px);
      }
      /* ---------------------- MCQ/Testlet Layout CSS ---------------------- */
      #testletContainer,
      #results {
        background-color: #fff;
        border-radius: 8px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        padding: 10px;
        margin-bottom: 20px;
        display: none;
        width: 100%;
      }
      #testletContainer.activeSection,
      #results.activeSection {
        display: block !important;
      }
      /* Timer Bar */
      #timerBar {
        font-weight: 700;
        font-size: 1.1rem;
        margin-bottom: 15px;
        color: #dc2626;
      }
      /* Question Navigation Bar */
      #questionNavBar {
        margin-bottom: 15px;
      }
      .navRow {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 10px;
      }
      /* Save/Exit Bar – adjust button spacing within this container */
      #saveExitBar {
        display: flex;
        align-items: center;
        gap: 6px; /* Reduced gap so buttons are almost touching */
      }
      /* Override the global button right margin for these buttons */
      #saveExitBar button.btnCalc,
      #saveExitBar button.btnPause {
        margin-right: 0;
      }
      /* Testlet title (exam name) and subtopic. */
      #testletTitle {
        font-size: 1.2rem;
        font-weight: bold;
        margin: 0;
      }
      #subtopicDisplay {
        font-size: 0.8rem;
        font-weight: normal;
        margin: 0;
      }
      /* Buttons styling for Help, Calculator, Hint, Pause, Exit to have uniform size */
      .btnCalc {
        background-color: #444;
        color: #fff;
        border: none;
        width: 35px;
        height: 30px;
        text-align: center;
        border-radius: 5px;
        padding: 0 2px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .btnCalc:hover {
        background-color: #333;
      }
      .btnPause {
        background-color: #444;
        color: #fff;
        border: none;
        width: 35px;
        height: 30px;
        text-align: center;
        border-radius: 5px;
        padding: 0;
        font-size: 16px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .btnPause:hover {
        background-color: #333;
      }
      .btnExit {
        background-color: #f00;
        color: #fff;
        border: none;
        padding: 4px;
        max-width: 40px;
        border-radius: 5px;
        display: flex;
        align-items: center;
        justify-content: center;
        line-height: 1;
      }
      .btnExit:hover {
        background-color: #c00;
      }
      /* Progress bar */
      #progressBar {
        width: 100%;
        background-color: #ccc;
        border-radius: 10px;
        overflow: hidden;
        height: 20px;
        position: relative;
      }
      #progressBarFill {
        height: 100%;
        width: 0%;
        background-color: #4A90E2;
      }
      /* Progress bar text overlay */
      #progressText {
        position: absolute;
        width: 100%;
        text-align: center;
        line-height: 20px;
        color: black;
        font-size: 12px;
        pointer-events: none;
      }
      /* Dropdown navigation – same width as progress bar */
      #dropdownRow {
        width: 100%;
      }
      #questionSelect {
        width: 100%;
        background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='5'%3E%3Cpath fill='%23666' d='M0 0l5 5 5-5z'/%3E%3C/svg%3E")
          no-repeat right center;
        background-size: 10px 5px;
        padding-right: 20px;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
      }
      /* Questions wrapper */
      #questionsWrapper {
        margin-bottom: 20px;
      }
      .questionItem {
        margin-bottom: 20px;
        padding: 15px;
        border-bottom: 1px solid #eee;
      }
      .questionItem:last-child {
        border-bottom: none;
      }
      .answers label {
        display: block;
        margin-bottom: 6px;
        cursor: pointer;
      }
      /* Make the option letter (A), B), etc.) a bit bolder */
      .optionLetter {
        font-weight: bold;
      }
      /* Action Buttons (Show Answer and Next Question) */
      #actionBtn,
      #showAnswerBtn {
        font-family: inherit;
        font-size: 1rem;
        padding: 12px 20px;
        margin: 8px 0;
        border-radius: 6px;
        cursor: pointer;
        border: none;
      }
      #actionBtn {
        background-color: #4A90E2;
        color: #fff;
      }
      #actionBtn:hover {
        background-color: #357ABD;
      }
      #showAnswerBtn {
        background-color: #000;
        color: #fff;
      }
      #showAnswerBtn:hover {
        background-color: #555;
      }
      /* RESULTS PAGE STYLES */
      .exitBtn {
        background-color: #f00;
        color: #fff;
        border: none;
        padding: 10px 8px;
        margin: 5px;
        border-radius: 5px;
        cursor: pointer;
        display: inline-block;
        width: auto;
      }
      .exitBtn:hover {
        background-color: #c00;
      }
      .tryAgainBtn {
        background-color: #90ee90;
        color: #000;
        border: none;
        padding: 10px 8px;
        margin: 5px;
        border-radius: 5px;
        cursor: pointer;
        display: inline-block;
        width: auto;
      }
      .tryAgainBtn:hover {
        background-color: #76d376;
      }
      #printBtn {
        background-color: grey;
        color: #fff;
        border: none;
        padding: 10px 8px;
        margin: 5px;
        border-radius: 5px;
        cursor: pointer;
        display: inline-block;
        width: auto;
      }
      #printBtn:hover {
        background-color: #5e5e5e;
      }
      /* ---------------------- Calculator Popup CSS ---------------------- */
      #calculatorPopup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #ffffff;
        border-radius: 10px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
        padding: 0;
        z-index: 10000;
        display: none;
        width: 260px;
        font-family: "Roboto", sans-serif;
      }
      #calcDragBar {
        width: 100%;
        background: #4A90E2;
        cursor: move;
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
        display: flex;
        align-items: center;
        padding: 2px 10px;
      }
      .drag-lines {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        height: 16px;
      }
      .drag-lines div {
        width: 20px;
        height: 2px;
        background: #fff;
      }
      #calcClose {
        background: none;
        border: none;
        color: #000;
        font-size: 1.2rem;
        cursor: pointer;
        margin-left: auto;
      }
      #calculator {
        width: 100%;
        padding: 10px;
        background-color: #fafafa;
      }
      #calcDisplay {
        width: 100%;
        height: 50px;
        background: #eee;
        margin-bottom: 10px;
        text-align: right;
        font-size: 1.3rem;
        line-height: 50px;
        padding: 0 10px;
        border-radius: 5px;
        overflow-x: auto;
      }
      #calcButtons {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-gap: 6px;
      }
      #calcButtons button {
        padding: 12px;
        font-size: 1.1rem;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background 0.2s;
      }
      #calcButtons button.digit {
        background: #4A90E2;
        color: #fff;
      }
      #calcButtons button.digit:hover {
        background: #357ABD;
      }
      #calcButtons button.operator {
        background: #000;
        color: #fff;
      }
      #calcButtons button.operator:hover {
        background: #333;
      }
      #calcButtons button.clear {
        background: red;
        color: #fff;
      }
      #calcButtons button.clear:hover {
        background: darkred;
      }
      #calcButtons button.equals {
        grid-column: span 2;
      }
      /* ---------------------- Hint Popup CSS ---------------------- */
      #hintPopup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #ffffff;
        border-radius: 10px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
        padding: 0;
        z-index: 10000;
        display: none;
        width: 260px;
        font-family: "Roboto", sans-serif;
      }
      #hintDragBar {
        width: 100%;
        background: #4A90E2;
        cursor: move;
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
        display: flex;
        align-items: center;
        padding: 2px 10px;
      }
      #hintClose {
        background: none;
        border: none;
        color: #000;
        font-size: 1.2rem;
        cursor: pointer;
        margin-left: auto;
      }
      #hintContent {
        width: 100%;
        padding: 10px;
        background-color: #fafafa;
        overflow-y: auto;
        max-height: calc(80vh - 30px);
      }
      /* ---------------------- Help Popup CSS ---------------------- */
      #helpOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.3);
        display: none;
        z-index: 9999;
        overflow: hidden;
      }
      #helpPopup {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #fff;
        border: 1px solid #ccc;
        border-radius: 8px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
        resize: both;
        overflow: hidden;
        min-width: 300px;
        min-height: 200px;
        width: 95vw;
        height: 80vh;
      }
      #helpPopupHeader {
        background: #4A90E2;
        color: #fff;
        padding: 2px 10px;
        font-size: 0.9rem;
        display: flex;
        align-items: center;
        cursor: move;
      }
      #helpPopupHeader .drag-lines {
        margin-right: 8px;
      }
      .help-buttons {
        margin-left: auto;
        display: flex;
        gap: 5px;
        align-items: center;
      }
      #helpClose {
        background: none;
        border: none;
        color: #000 !important;
        font-size: 1.2rem;
        cursor: pointer;
      }
      #helpIframe {
        width: 100%;
        height: calc(100% - 24px);
        border: none;
      }
      /* ---------------------- Historical Scores Popup CSS ---------------------- */
      #historicalScoresOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.3);
        display: none;
        z-index: 9999;
        overflow: hidden;
      }
      #historicalScoresPopup {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #fff;
        border: 1px solid #ccc;
        border-radius: 8px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
        resize: both;
        overflow: auto;
        min-width: 300px;
        min-height: 200px;
        width: 80vw;
        height: 70vh;
        padding: 0;
      }
      #historicalScoresHeader {
        background: #4A90E2;
        color: #fff;
        padding: 2px 10px;
        font-size: 0.9rem;
        display: flex;
        align-items: center;
        cursor: move;
      }
      #historicalScoresContent {
        padding: 15px;
        overflow-y: auto;
        max-height: calc(100% - 30px);
      }
      #historicalScoresClose {
        background: none;
        border: none;
        color: #000 !important;
        font-size: 1.2rem;
        cursor: pointer;
        margin-left: auto;
      }
      .historyBtn {
        background-color: #4A90E2;
        color: #fff;
        border: none;
        padding: 10px 8px;
        margin: 5px;
        border-radius: 5px;
        cursor: pointer;
        display: inline-block;
        width: auto;
      }
      .historyBtn:hover {
        background-color: #357ABD;
      }
      .history-loading {
        text-align: center;
        padding: 20px;
      }
      .history-error {
        color: red;
        text-align: center;
        padding: 20px;
      }
      .history-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 10px;
      }
      .history-table th, .history-table td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
      }
      .history-table th {
        background-color: #f2f2f2;
      }
      /* Styling for Unattempted Topics Section */
      .unattempted-section {
        margin-top: 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
      }
      .unattempted-group {
        flex: 1 1 300px;
        background-color: #f9f9f9;
        border-radius: 6px;
        padding: 10px;
        margin-bottom: 10px;
      }
      .unattempted-group h5 {
        margin-top: 0;
        margin-bottom: 8px;
        color: #333;
        border-bottom: 1px solid #ddd;
        padding-bottom: 5px;
      }
      .unattempted-group ul {
        margin: 0;
        padding-left: 20px;
      }
      .unattempted-group li {
        margin-bottom: 4px;
        color: #666;
      }
      /* ---------------------- Mobile Tweaks ---------------------- */
      @media (max-width: 600px) {
        html,
        body {
          padding: 1px;
          margin: 0;
        }
        #setup,
        #testletContainer,
        #results {
          padding: 4px;
          margin: 1px 3px 1px 1px;
        }
        
        /* Mobile styles for the question review section */
        .question-review {
          padding: 10px !important;
          margin-bottom: 20px !important;
        }
        
        .question-review h4 {
          font-size: 1.1em;
          margin-bottom: 8px;
        }
        
        .question-review .options p,
        .question-review .answer-review p,
        .question-review .metadata p {
          font-size: 0.9em;
          margin: 5px 0;
        }
        
        .question-review .answer-review {
          padding: 8px !important;
        }
      }
      @media (max-width: 600px) {
        #helpPopup {
          top: 15%;
          transform: translate(-50%, 0);
        }
      }
    </style>
  </head>
  <body>
    <!-- SETUP PAGE -->
    <div id="setup">
      <div>
        <label for="examSelect">Select Exam <span style="color: red;">(required)</span></label>
        <select id="examSelect">
          <option value="">-- Choose Exam --</option>
          <option value="FAR">FAR</option>
          <option value="REG">REG</option>
          <option value="AUD">AUD</option>
          <option value="BAR">BAR</option>
          <option value="ISC">ISC</option>
          <option value="TCP">TCP</option>
        </select>
      </div>
      <div>
        <label for="subtopicSelect">Select Subtopics <span style="color: red;">(required)</span></label>
        <select id="subtopicSelect" multiple size="5">
          <option value="">-- Choose Exam First --</option>
        </select>
        <div id="loadingIndicator"></div>
      </div>
      <div>
        <label for="microtopicSelect">Select Microtopics</label>
        <select id="microtopicSelect" multiple size="5">
          <option value="All" selected>All</option>
        </select>
      </div>
      <!-- New Difficulty Toggle (All = Off, Hard = On) -->
      <div class="toggle-container">
        <label for="difficultyToggle">Difficulty</label>
        <label class="switch">
          <input type="checkbox" id="difficultyToggle">
          <span class="slider"></span>
        </label>
        <span id="difficultyLabel">All</span>
      </div>
      <div>
        <label for="numQSelect">Number of Questions</label>
        <select id="numQSelect"></select>
      </div>
      <div>
        <label for="timerSelect">Time Limit (per question)</label>
        <select id="timerSelect">
          <option value="0">No timer (default)</option>
          <option value="15">15 seconds</option>
          <option value="30">30 seconds</option>
          <option value="45">45 seconds</option>
          <option value="60">60 seconds</option>
          <option value="75">75 seconds</option>
          <option value="90">90 seconds</option>
          <option value="105">105 seconds</option>
          <option value="120">120 seconds</option>
          <option value="135">135 seconds</option>
          <option value="150">150 seconds</option>
          <option value="165">165 seconds</option>
          <option value="180">180 seconds</option>
        </select>
      </div>
      <button id="startQuizBtn" disabled>Start Quiz</button>
    </div>
    <!-- TESTLET DISPLAY PAGE -->
    <div id="testletContainer">
      <!-- Timer Display -->
      <div id="timerBar">Time Remaining: --</div>
      <!-- Testlet Navigation Bar -->
      <div id="questionNavBar">
        <div class="navRow" id="saveExitBarRow">
          <div>
            <h3 id="testletTitle">Exam</h3>
            <p id="subtopicDisplay"></p>
          </div>
          <div id="saveExitBar">
            <!-- Hint Button; will only be shown if the current question has a hint -->
            <button id="hintBtn" class="btnCalc" title="Hint">&#128161;</button>
            <!-- Help button now uses a textbook/books icon -->
            <button id="helpBtn" class="btnCalc" title="Help">&#128218;</button>
            <button id="calcBtn" class="btnCalc" title="Calculator">
              <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 448 512">
                <path fill="currentColor" d="M400 0H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V48c0-26.5-21.5-48-48-48zm-224 416c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm0-96c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm96 96c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm0-96c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32z"/>
              </svg>
            </button>
            <button id="pauseBtn" class="btnPause">&#10073;&#10073;</button>
            <button id="exitTestletBtn" class="btnExit" onclick="location.reload()">Exit</button>
          </div>
        </div>
        <div class="navRow" id="progressBarRow">
          <div id="progressBar">
            <div id="progressBarFill"></div>
            <div id="progressText">0 out of 0</div>
          </div>
        </div>
        <div class="navRow" id="dropdownRow">
          <select id="questionSelect"></select>
        </div>
      </div>
      <!-- Questions Display Area -->
      <div id="questionsWrapper"></div>
      <!-- Action Buttons -->
      <div style="display: flex; gap: 10px; margin-top: 15px;">
        <button id="showAnswerBtn" class="btnSecondary">Show Answer</button>
        <button id="actionBtn" class="btnPrimary">Next Question</button>
      </div>
    </div>
    <!-- RESULTS PAGE -->
    <div id="results">
      <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;">
        <button class="exitBtn" onclick="location.reload()">Exit</button>
        <button class="tryAgainBtn" onclick="retakeQuiz()">Try Again</button>
        <button id="getHistoricalScoresBtn" class="historyBtn">Get Historical Scores</button>
      </div>
      <h2>Quiz Results</h2>
      <div id="summary"></div>
      <div id="breakdown"></div>
      <h3>Review of All Questions</h3>
      <div id="review"></div>
      <button id="printBtn">Print to PDF</button>
      <div style="display: flex; flex-wrap: wrap; gap: 10px;">
        <button class="exitBtn" onclick="location.reload()">Exit</button>
        <button class="tryAgainBtn" onclick="retakeQuiz()">Try Again</button>
      </div>
    </div>
    <!-- Calculator Popup -->
    <div id="calculatorPopup">
      <div id="calcDragBar">
        <div class="drag-lines">
          <div></div>
          <div></div>
          <div></div>
        </div>
        <button id="calcClose" title="Close Calculator">X</button>
      </div>
      <div id="calculator">
        <div id="calcDisplay">0</div>
        <div id="calcButtons">
          <button data-value="7" class="digit">7</button>
          <button data-value="8" class="digit">8</button>
          <button data-value="9" class="digit">9</button>
          <button data-value="/" class="operator">/</button>
          <button data-value="4" class="digit">4</button>
          <button data-value="5" class="digit">5</button>
          <button data-value="6" class="digit">6</button>
          <button data-value="*" class="operator">*</button>
          <button data-value="1" class="digit">1</button>
          <button data-value="2" class="digit">2</button>
          <button data-value="3" class="digit">3</button>
          <button data-value="-" class="operator">-</button>
          <button data-value="0" class="digit">0</button>
          <button data-value="." class="operator">.</button>
          <button data-action="clear" class="clear">C</button>
          <button data-value="+" class="operator">+</button>
          <button data-action="square" class="operator">x²</button>
          <button data-action="sqrt" class="operator">√</button>
          <button data-action="equals" class="operator equals">=</button>
        </div>
      </div>
    </div>
    <!-- Hint Popup -->
    <div id="hintPopup">
      <div id="hintDragBar">
        <div class="drag-lines">
          <div></div>
          <div></div>
          <div></div>
        </div>
        <button id="hintClose" title="Close Hint">X</button>
      </div>
      <div id="hintContent">
        <!-- Hint content will be injected here -->
      </div>
    </div>
    <!-- Help Popup -->
    <div id="helpOverlay">
      <div id="helpPopup">
        <div id="helpPopupHeader">
          <div class="drag-lines">
            <div></div>
            <div></div>
            <div></div>
          </div>
          <span>Help</span>
          <div class="help-buttons">
            <button id="helpClose" title="Close Help">X</button>
          </div>
        </div>
        <iframe id="helpIframe"></iframe>
      </div>
    </div>
    <!-- Historical Scores Popup -->
    <div id="historicalScoresOverlay">
      <div id="historicalScoresPopup">
        <div id="historicalScoresHeader">
          <div class="drag-lines">
            <div></div>
            <div></div>
            <div></div>
          </div>
          <span>Historical Scores</span>
          <div class="help-buttons">
            <button id="historicalScoresClose" title="Close">X</button>
          </div>
        </div>
        <div id="historicalScoresContent">
          <!-- Historical scores content will be injected here -->
        </div>
      </div>
    </div>
    <script>
      // Global CSV URL building and configuration
      const urlProtocol = "https://";
      const urlHost = "docs.google.com";
      const urlPath = "/spreadsheets/d/e/";
      const urlId =
        "2PACX-1vRdFvUqqtsGvWKzcT4sSqnZNLeLxrSYnWE2RJNPdtbkVRlH-vnj9ZZH1PIIMEaV7w";
      const urlTail = "/pub";
      const urlQueryStart = "?gid=";
      const urlQueryEnd = "&single=true&output=csv";
      function getCsvUrl(gid) {
        return (
          urlProtocol +
          urlHost +
          urlPath +
          urlId +
          urlTail +
          urlQueryStart +
          gid +
          urlQueryEnd
        );
      }
      // GLOBAL VARIABLES AND CONFIGURATION
      const examCSVMap = {
        FAR: getCsvUrl("1687873019"),
        REG: getCsvUrl("1800061537"),
        AUD: getCsvUrl("861732103"),
        BAR: getCsvUrl("95134214"),
        ISC: getCsvUrl("682399307"),
        TCP: getCsvUrl("1659970016")
      };
      // Help CSV URL
      const helpCSVUrl = getCsvUrl("2060423319");
      // Taxonomy CSV URL (exam, subtopic, microtopic structure)
      const taxonomyCSVUrl = getCsvUrl("726401979");
      let allQuestions = [];
      // NEW: Cache questions per exam so that when a new exam is chosen, we load new data.
      const examQuestionsCache = {};
      let quizQuestions = [];
      let currentQuestionIndex = 0;
      let userAnswers = [];
      let questionTimer = null;
      let timeLeft = 0;
      let chosenTimeLimit = 0;
      let timerInterval = null;
      let calcExpression = "";
      // Global help CSV data array
      let helpCSVData = [];
      // Global taxonomy data
      let taxonomyData = {
        subtopics: {},
        microtopics: {},
        microToSub: {}
      };
      let currentSessionId = null;
      let isPaused = false;
      document.addEventListener("DOMContentLoaded", () => {
        console.log("Setting up quiz...");
        populateNumQuestions();
        loadHelpCSV();
        loadTaxonomyData();
        document.getElementById("examSelect").addEventListener("change", handleExamChange);
        document.getElementById("subtopicSelect").addEventListener("change", handleSubtopicChange);
        document.getElementById("examSelect").addEventListener("change", enableStartQuizIfReady);
        document.getElementById("subtopicSelect").addEventListener("change", enableStartQuizIfReady);
        document.getElementById("numQSelect").addEventListener("change", enableStartQuizIfReady);
        document.getElementById("microtopicSelect").addEventListener("change", enableStartQuizIfReady);
        document.getElementById("timerSelect").addEventListener("change", enableStartQuizIfReady);
        document.getElementById("startQuizBtn").addEventListener("click", startQuiz);
        document.getElementById("difficultyToggle").addEventListener("change", () => {
          const diffLabel = document.getElementById("difficultyLabel");
          diffLabel.textContent = document.getElementById("difficultyToggle").checked ? "Hard" : "All";
        });
        document.getElementById("pauseBtn").addEventListener("click", togglePause);
        document.getElementById("exitTestletBtn").addEventListener("click", () => { location.reload(); });
        document.getElementById("helpBtn").addEventListener("click", openHelpPopup);
        document.getElementById("helpClose").addEventListener("click", closeHelpPopup);
        document.getElementById("helpOverlay").addEventListener("click", (e) => {
          if (e.target === document.getElementById("helpOverlay")) closeHelpPopup();
        });
        document.getElementById("calcBtn").addEventListener("click", toggleCalculator);
        document.getElementById("calcClose").addEventListener("click", toggleCalculator);
        document.getElementById("hintBtn").addEventListener("click", openHintPopup);
        document.getElementById("hintClose").addEventListener("click", closeHintPopup);
        document.getElementById("showAnswerBtn").addEventListener("click", handleShowAnswer);
        document.getElementById("actionBtn").addEventListener("click", nextQuestion);
        document.getElementById("printBtn").addEventListener("click", function () { window.print(); });
        document.getElementById("getHistoricalScoresBtn").addEventListener("click", openHistoricalScoresPopup);
        document.getElementById("historicalScoresClose").addEventListener("click", closeHistoricalScoresPopup);
        document.getElementById("historicalScoresOverlay").addEventListener("click", (e) => {
          if (e.target === document.getElementById("historicalScoresOverlay")) closeHistoricalScoresPopup();
        });
        initHistoricalScoresDrag();
        document.addEventListener("keydown", (e) => {
          const calcPopup = document.getElementById("calculatorPopup");
          if (calcPopup.style.display !== "none") {
            const allowedKeys = "0123456789.+-*/";
            if (allowedKeys.includes(e.key)) {
              calcExpression += e.key;
              updateCalcDisplay();
              e.preventDefault();
            } else if (e.key === "Enter") {
              performEquals();
              e.preventDefault();
            } else if (e.key === "Backspace") {
              calcExpression = calcExpression.slice(0, -1);
              updateCalcDisplay();
              e.preventDefault();
            } else if (e.key === "Escape") {
              toggleCalculator();
              e.preventDefault();
            }
          }
        });
        initCalculator();
        initCalculatorDrag();
        initHelpDrag();
        initHintDrag();
      });
      function populateNumQuestions() {
        const sel = document.getElementById("numQSelect");
        sel.innerHTML = "";
        for (let i = 1; i <= 50; i++) {
          const opt = document.createElement("option");
          opt.value = i;
          opt.textContent = i;
          if (i === 10) opt.selected = true;
          sel.appendChild(opt);
        }
      }
      function enableStartQuizIfReady() {
        const exam = document.getElementById("examSelect").value;
        const numQ = document.getElementById("numQSelect").value;
        const subtopics = Array.from(document.getElementById("subtopicSelect").selectedOptions)
          .map(o => o.value)
          .filter(v => v !== "");
        const startBtn = document.getElementById("startQuizBtn");
        startBtn.disabled = !(exam && numQ && subtopics.length > 0);
      }
      // Modified: When an exam is chosen, we clear the subtopicSelect and load the CSV for that exam.
      async function handleExamChange() {
        console.log("Exam changed");
        const exam = document.getElementById("examSelect").value;
        const subtopicSelect = document.getElementById("subtopicSelect");
        const microtopicSelect = document.getElementById("microtopicSelect");
        const loadingIndicator = document.getElementById("loadingIndicator");
        loadingIndicator.style.display = "flex";
        loadingIndicator.innerHTML = '<div class="spinner"></div><span>Loading subtopics...</span>';
        subtopicSelect.innerHTML = "";
        if (!exam) {
          subtopicSelect.innerHTML = "<option value=''>-- Choose Exam First --</option>";
          microtopicSelect.innerHTML = "<option value='All' selected>All</option>";
          loadingIndicator.style.display = "none";
          return;
        }
        const csvUrl = examCSVMap[exam];
        if (!csvUrl) {
          subtopicSelect.innerHTML = "<option value=''>-- No CSV for this exam --</option>";
          microtopicSelect.innerHTML = "<option value='All' selected>All</option>";
          loadingIndicator.style.display = "none";
          return;
        }
        // NEW: Use the cache if available; otherwise load questions for this exam and cache them.
        if (examQuestionsCache[exam]) {
          allQuestions = examQuestionsCache[exam];
        } else {
          try {
            await loadQuestionsFromCSV(csvUrl, exam);
          } catch (err) {
            console.error("Failed to load/parse CSV:", err);
            subtopicSelect.innerHTML = "<option value=''>-- Error Loading CSV --</option>";
            loadingIndicator.style.display = "none";
            return;
          }
        }
        let subtopicsArray = [];
        if (taxonomyData.subtopics && taxonomyData.subtopics[exam] && taxonomyData.subtopics[exam].length > 0) {
          console.log("Using taxonomy data for subtopics");
          subtopicsArray = [...taxonomyData.subtopics[exam]];
        } else {
          console.log("Using questions data for subtopics");
          const subtopicsSet = new Set();
          allQuestions.forEach(q => {
            if (q.Exam && q.Exam.trim() === exam.trim() && q.Subtopic && q.Subtopic.trim()) {
              subtopicsSet.add(q.Subtopic.trim());
            }
          });
          subtopicsArray = Array.from(subtopicsSet);
        }
        subtopicsArray.sort();
        subtopicsArray.unshift("All");
        subtopicsArray.forEach(st => {
          const option = document.createElement("option");
          option.value = st;
          option.textContent = st;
          subtopicSelect.appendChild(option);
        });
        microtopicSelect.innerHTML = "<option value='All' selected>All</option>";
        handleSubtopicChange();
        loadingIndicator.style.display = "none";
      }
      function handleSubtopicChange() {
        const exam = document.getElementById("examSelect").value;
        const microtopicSelect = document.getElementById("microtopicSelect");
        const selectedSubtopics = Array.from(document.getElementById("subtopicSelect").selectedOptions).map(opt => opt.value);
        microtopicSelect.innerHTML = "";
        if (!exam) {
          const allOption = document.createElement("option");
          allOption.value = "All";
          allOption.textContent = "All";
          allOption.selected = true;
          microtopicSelect.appendChild(allOption);
          return;
        }
        const allOption = document.createElement("option");
        allOption.value = "All";
        allOption.textContent = "All";
        allOption.selected = true;
        microtopicSelect.appendChild(allOption);
        if (selectedSubtopics.length === 0) {
          return;
        }
        const showAllSubtopics = selectedSubtopics.includes("All");
        const uniqueMicrotopics = new Set();
        if (taxonomyData.microtopics && taxonomyData.microtopics[exam]) {
          console.log("Using taxonomy data for microtopics");
          if (showAllSubtopics) {
            Object.keys(taxonomyData.microtopics[exam]).forEach(subtopic => {
              if (taxonomyData.microtopics[exam][subtopic]) {
                taxonomyData.microtopics[exam][subtopic].forEach(microtopic => {
                  if (microtopic && microtopic.trim()) {
                    uniqueMicrotopics.add(microtopic);
                  }
                });
              }
            });
          } else {
            selectedSubtopics.forEach(subtopic => {
              if (taxonomyData.microtopics[exam][subtopic]) {
                taxonomyData.microtopics[exam][subtopic].forEach(microtopic => {
                  if (microtopic && microtopic.trim()) {
                    uniqueMicrotopics.add(microtopic);
                  }
                });
              }
            });
          }
        }
        if (uniqueMicrotopics.size === 0) {
          console.log("Falling back to questions data for microtopics");
          allQuestions.forEach(q => {
            if (q.Exam.trim() === exam.trim() && q.Microtopic && q.Microtopic.trim()) {
              if (showAllSubtopics || selectedSubtopics.includes(q.Subtopic.trim())) {
                uniqueMicrotopics.add(q.Microtopic.trim());
              }
            }
          });
        }
        Array.from(uniqueMicrotopics).sort().forEach(mt => {
          const option = document.createElement("option");
          option.value = mt;
          option.textContent = mt;
          microtopicSelect.appendChild(option);
        });
        microtopicSelect.value = "All";
      }
      // Modified: Added exam parameter to cache questions for that exam.
      async function loadQuestionsFromCSV(csvUrl, exam) {
        try {
          const response = await fetch(csvUrl);
          const csvText = await response.text();
          const parsed = Papa.parse(csvText, { header: true, skipEmptyLines: true });
          allQuestions = parsed.data.map(row => ({
            Exam: row["Exam"] || "",
            Subtopic: row["Subtopic"] || "",
            Question: row["Question"] || "",
            A: row["A"] || "",
            B: row["B"] || "",
            C: row["C"] || "",
            D: row["D"] || "",
            Correct: row["Correct"] || "",
            Explanation: row["Explanation"] || "",
            Tags: "",
            Hint: row["Hint"] || "",
            Microtopic: row["microtopic"] || "",
            imageURL: row["imageURL"] || "",
            hard: row["hard"] || ""
          }));
          examQuestionsCache[exam] = allQuestions;
        } catch (err) {
          console.error("Failed to load/parse CSV:", err);
          throw err;
        }
      }
      async function loadHelpCSV() {
        fetch(helpCSVUrl)
          .then(response => response.text())
          .then(csvText => {
            const parsed = Papa.parse(csvText, { header: true, skipEmptyLines: true });
            helpCSVData = parsed.data;
            console.log("Help CSV loaded successfully");
          })
          .catch(err => {
            console.error("Failed to load/parse Help CSV:", err);
          });
      }
      function startQuiz() {
        const exam = document.getElementById("examSelect").value;
        const subtopicSelect = document.getElementById("subtopicSelect");
        const microtopicSelect = document.getElementById("microtopicSelect");
        const selectedSubtopics = Array.from(subtopicSelect.selectedOptions).map(opt => opt.value);
        const selectedMicrotopics = Array.from(microtopicSelect.selectedOptions).map(opt => opt.value);
        const numQSelect = document.getElementById("numQSelect");
        const numQuestions = numQSelect ? numQSelect.value : "10";
        const quizData = {
          exam: exam,
          subtopics: selectedSubtopics,
          microtopics: selectedMicrotopics,
          numQuestions: numQuestions
        };
        
        // Get the SiteUserInfo cookie instead of IP address
        let siteUserId = "Unknown";
        const siteUserInfoCookie = document.cookie.split('; ').find(row => row.startsWith('SiteUserInfo='));
        if (siteUserInfoCookie) {
          try {
            const decodedCookie = decodeURIComponent(siteUserInfoCookie.split('=')[1]);
            const userInfo = JSON.parse(decodedCookie);
            if (userInfo && userInfo.siteUserId) {
              siteUserId = userInfo.siteUserId;
            }
          } catch (err) {
            console.error("Error parsing SiteUserInfo cookie:", err);
          }
        }
        
        const logData = {
          type: "start",
          sessionId: generateSessionId(),
          ip: siteUserId, // Using siteUserId instead of IP
          exam: quizData.exam,
          subtopics: quizData.subtopics.join(", "),
          microtopics: quizData.microtopics.join(", "),
          numQuestions: quizData.numQuestions,
          sourceUrl: window.location.href
        };
        
        fetch('https://script.google.com/macros/s/AKfycbxiinfolz65zvpjx3w15rsoA1SltnfYA3Pq3sdoMCAEgzbXHweta-Uld1KXVeaTQOr1Eg/exec', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(logData),
          mode: 'no-cors'
        })
        .then(response => {
          console.log('Start logging request sent');
        })
        .catch(error => {
          console.error('Error logging to Google Sheet:', error);
        })
        .finally(() => {
          startQuizLogic(quizData);
        });
      }
      function startQuizLogic(data) {
        const exam = data.exam;
        const selectedSubtopics = data.subtopics;
        const selectedMicrotopics = data.microtopics;
        document.getElementById("setup").style.display = "none";
        document.getElementById("testletContainer").style.display = "block";
        document.getElementById("results").style.display = "none";
        document.getElementById("testletTitle").textContent = exam;
        document.getElementById("subtopicDisplay").textContent = selectedSubtopics.join(", ");
        console.log("Starting quiz with exam:", exam);
        console.log("Selected subtopics:", selectedSubtopics);
        console.log("Selected microtopics:", selectedMicrotopics);
        try {
          currentQuestionIndex = 0;
          userAnswers = [];
          const difficulty = document.getElementById("difficultyToggle") && document.getElementById("difficultyToggle").checked ? "hard" : "all";
          let filtered = allQuestions.filter(q => q.Exam.trim() === exam.trim());
          if (!selectedSubtopics.includes("All")) {
            filtered = filtered.filter(q => selectedSubtopics.includes(q.Subtopic.trim()));
          }
          if (!selectedMicrotopics.includes("All")) {
            filtered = filtered.filter(q => selectedMicrotopics.includes(q.Microtopic.trim()));
          }
          if (difficulty === "hard") {
            filtered = filtered.filter(q => q.hard && q.hard.trim().toLowerCase() === "hard");
          }
          shuffleArray(filtered);
          const numQSelect = document.getElementById("numQSelect");
          const numQ = parseInt(numQSelect.value, 10);
          quizQuestions = filtered.slice(0, numQ);
          console.log("Prepared quiz questions:", quizQuestions);
          if (quizQuestions.length === 0) {
            alert("No questions found for your selection. Please try different criteria.");
            document.getElementById("setup").style.display = "block";
            document.getElementById("testletContainer").style.display = "none";
            return;
          }
          quizQuestions.forEach(q => q.userAnswer = "");
          populateQuestionDropdown();
          showQuestion(0);
          updateProgressBar();
        } catch (error) {
          console.error("Error starting quiz:", error);
          alert("There was an error starting the quiz. Please try again.");
          document.getElementById("setup").style.display = "block";
          document.getElementById("testletContainer").style.display = "none";
        }
      }
      function populateQuestionDropdown() {
        const select = document.getElementById("questionSelect");
        select.innerHTML = "";
        quizQuestions.forEach((q, i) => {
          let opt = document.createElement("option");
          opt.value = i;
          opt.textContent = (q.userAnswer ? "✅ " : "☐ ") + "Question " + (i + 1);
          select.appendChild(opt);
        });
        select.value = currentQuestionIndex;
        select.addEventListener("change", (e) => {
          const newIndex = parseInt(e.target.value, 10);
          if (!isNaN(newIndex)) showQuestion(newIndex);
        });
      }
      function showQuestion(index) {
        if (index < 0 || index >= quizQuestions.length) { finishQuiz(); return; }
        currentQuestionIndex = index;
        document.getElementById("questionSelect").value = index;
        stopQuestionTimer();
        chosenTimeLimit = parseInt(document.getElementById("timerSelect").value, 10);
        var timerBar = document.getElementById("timerBar");
        if (chosenTimeLimit > 0) {
          timerBar.style.display = "block";
          timeLeft = chosenTimeLimit;
          timerBar.textContent = "Time Remaining: " + timeLeft + " s";
          isPaused = false;
          document.getElementById("pauseBtn").innerHTML = "&#10073;&#10073;";
          questionTimer = setInterval(function() {
            if (!isPaused) {
              timeLeft--;
              timerBar.textContent = "Time Remaining: " + timeLeft + " s";
              if (timeLeft <= 0) {
                stopQuestionTimer();
                autoRevealAnswer();
              }
            }
          }, 1000);
        } else {
          timerBar.style.display = "none";
        }
        const qData = quizQuestions[index];
        const wrapper = document.getElementById("questionsWrapper");
        wrapper.innerHTML = "";
        const oldFeedback = document.getElementById("feedback_answer");
        if (oldFeedback) oldFeedback.remove();
        document.getElementById("actionBtn").textContent = (currentQuestionIndex === quizQuestions.length - 1) ? "Submit Quiz" : "Next Question";
        document.getElementById("showAnswerBtn").textContent = "Show Answer";
        let html = `<div class="questionItem">
                      <p>${escapeHTML(qData.Question)}</p>
                      <div class="answers">
                        <label><input type="radio" name="mcq_${index}" value="A"> <strong>A)</strong> ${escapeHTML(qData.A)}</label>
                        <label><input type="radio" name="mcq_${index}" value="B"> <strong>B)</strong> ${escapeHTML(qData.B)}</label>
                        <label><input type="radio" name="mcq_${index}" value="C"> <strong>C)</strong> ${escapeHTML(qData.C)}</label>
                        <label><input type="radio" name="mcq_${index}" value="D"> <strong>D)</strong> ${escapeHTML(qData.D)}</label>
                      </div>
                    </div>`;
        wrapper.innerHTML = html;
        document.querySelectorAll(`input[name="mcq_${index}"]`).forEach(radio => {
          radio.addEventListener("change", (e) => {
            quizQuestions[currentQuestionIndex].userAnswer = e.target.value;
            userAnswers[currentQuestionIndex] = { selected: e.target.value };
            updateQuestionDropdownOption(currentQuestionIndex);
          });
          if (quizQuestions[index].userAnswer) {
            if (radio.value === quizQuestions[index].userAnswer)
              radio.checked = true;
          }
        });
        if (qData.Hint && qData.Hint.trim() !== "") {
          document.getElementById("hintBtn").style.display = "flex";
        } else {
          document.getElementById("hintBtn").style.display = "none";
        }
        updateProgressBar();
        window.scrollTo(0, 0);
      }
      function updateQuestionDropdownOption(idx) {
        const select = document.getElementById("questionSelect");
        if (select && select.options[idx]) {
          select.options[idx].textContent = (quizQuestions[idx].userAnswer ? "✅ " : "☐ ") + "Question " + (idx + 1);
        }
      }
      function updateProgressBar() {
        const percent = ((currentQuestionIndex + 1) / quizQuestions.length) * 100;
        document.getElementById("progressBarFill").style.width = percent + "%";
        document.getElementById("progressText").textContent = (currentQuestionIndex + 1) + " out of " + quizQuestions.length;
      }
      function handleShowAnswer() {
        const qData = quizQuestions[currentQuestionIndex];
        const wrapper = document.getElementById("questionsWrapper");
        let feedbackDiv = document.getElementById("feedback_answer");
        if (feedbackDiv) {
          feedbackDiv.remove();
          document.getElementById("showAnswerBtn").textContent = "Show Answer";
        } else {
          feedbackDiv = document.createElement("div");
          feedbackDiv.id = "feedback_answer";
          feedbackDiv.className = "feedbackMsg";
          const userAns = qData.userAnswer ? qData.userAnswer.trim().toUpperCase() : "";
          const correctAns = qData.Correct.trim().toUpperCase();
          let msg = "";
          if (userAns === correctAns && userAns !== "") {
            msg += `<p style="color: green; font-weight: bold;">Correct!</p>`;
          } else {
            msg += `<p style="color: red; font-weight: bold;">Incorrect</p>`;
          }
          msg += `<p><strong>Correct Answer:</strong> ${escapeHTML(qData.Correct)}</p>
                  <p><strong>Explanation:</strong> ${escapeHTML(qData.Explanation)}</p>`;
          feedbackDiv.innerHTML = msg;
          wrapper.appendChild(feedbackDiv);
          document.getElementById("showAnswerBtn").textContent = "Hide Answer";
        }
      }
      function nextQuestion() {
        const oldFeedback = document.getElementById("feedback_answer");
        if (oldFeedback) oldFeedback.remove();
        document.getElementById("showAnswerBtn").textContent = "Show Answer";
        currentQuestionIndex++;
        if (currentQuestionIndex >= quizQuestions.length) {
          finishQuiz();
        } else {
          showQuestion(currentQuestionIndex);
        }
      }
      function autoRevealAnswer() {
        quizQuestions[currentQuestionIndex].userAnswer = "No selection";
        userAnswers[currentQuestionIndex] = { selected: "No selection" };
        handleShowAnswer();
      }
      function finishQuiz() {
        document.getElementById("testletContainer").style.display = "none";
        document.getElementById("results").style.display = "block";
        window.scrollTo(0, 0);
        const total = quizQuestions.length;
        let correctCount = 0;
        quizQuestions.forEach(q => {
          if (q.userAnswer && q.userAnswer.trim().toUpperCase() === q.Correct.trim().toUpperCase()) {
            correctCount++;
          }
        });
        const percent = (total > 0) ? Math.round((correctCount / total) * 100).toFixed(1) : "0.0";
        document.getElementById("summary").innerHTML = `
          <p>You answered <strong>${correctCount}</strong> out of <strong>${total}</strong> questions correctly.</p>
          <p>Your score: <strong>${percent}%</strong></p>
        `;
        let breakdown = {};
        quizQuestions.forEach(q => {
          let key = (q.Subtopic && q.Subtopic.trim() !== "") ? q.Subtopic.trim() : "Unspecified";
          if (!breakdown[key]) breakdown[key] = { total: 0, correct: 0 };
          breakdown[key].total++;
          if ((q.userAnswer || "").trim().toUpperCase() === q.Correct.trim().toUpperCase()) {
            breakdown[key].correct++;
          }
        });
        let tableHTML = "<table style='width:100%; border-collapse: collapse; margin-top:10px;'>";
        tableHTML += "<tr><th style='border:1px solid #ddd; padding: 8px;'>Subtopic</th><th style='border:1px solid #ddd; padding: 8px;'>Total Questions</th><th style='border:1px solid #ddd; padding: 8px;'>Correct</th><th style='border:1px solid #ddd; padding: 8px;'>Score %</th></tr>";
        Object.keys(breakdown).forEach(sub => {
          let tot = breakdown[sub].total;
          let corr = breakdown[sub].correct;
          let score = ((corr/tot)*100).toFixed(1);
          tableHTML += `<tr><td style='border:1px solid #ddd; padding: 8px;'>${escapeHTML(sub)}</td><td style='border:1px solid #ddd; padding: 8px;'>${tot}</td><td style='border:1px solid #ddd; padding: 8px;'>${corr}</td><td style='border:1px solid #ddd; padding: 8px;'>${score}%</td></tr>`;
        });
        tableHTML += "</table>";
        let microBreakdown = {};
        quizQuestions.forEach(q => {
          let key = (q.Microtopic && q.Microtopic.trim() !== "") ? q.Microtopic.trim() : "Unspecified";
          if (!microBreakdown[key]) microBreakdown[key] = { total: 0, correct: 0 };
          microBreakdown[key].total++;
          if ((q.userAnswer || "").trim().toUpperCase() === q.Correct.trim().toUpperCase()) {
            microBreakdown[key].correct++;
          }
        });
        let tableHTMLMicro = "<table style='width:100%; border-collapse: collapse; margin-top:10px;'>";
        tableHTMLMicro += "<tr><th style='border:1px solid #ddd; padding: 8px;'>Microtopic</th><th style='border:1px solid #ddd; padding: 8px;'>Total Questions</th><th style='border:1px solid #ddd; padding: 8px;'>Correct</th><th style='border:1px solid #ddd; padding: 8px;'>Score %</th></tr>";
        Object.keys(microBreakdown).forEach(mt => {
          let tot = microBreakdown[mt].total;
          let corr = microBreakdown[mt].correct;
          let score = ((corr/tot)*100).toFixed(1);
          tableHTMLMicro += `<tr><td style='border:1px solid #ddd; padding: 8px;'>${escapeHTML(mt)}</td><td style='border:1px solid #ddd; padding: 8px;'>${tot}</td><td style='border:1px solid #ddd; padding: 8px;'>${corr}</td><td style='border:1px solid #ddd; padding: 8px;'>${score}%</td></tr>`;
        });
        tableHTMLMicro += "</table>";
        document.getElementById("breakdown").innerHTML = "<h3>Breakdown by Subsection</h3>" + tableHTML + 
                                                         "<br><h3>Breakdown by Microtopic</h3>" + tableHTMLMicro;
                                                         
        // Add detailed question review section
        let reviewHTML = "";
        quizQuestions.forEach((q, index) => {
          const userAnswer = q.userAnswer ? q.userAnswer.trim().toUpperCase() : "Not answered";
          const correctAnswer = q.Correct.trim().toUpperCase();
          const isCorrect = userAnswer === correctAnswer;
          
          reviewHTML += `
            <div class="question-review" style="margin-bottom: 30px; padding: 15px; border: 1px solid #ddd; border-radius: 8px; background-color: ${isCorrect ? '#f0fff0' : '#fff0f0'}">
              <h4>Question ${index + 1}</h4>
              <p><strong>Question:</strong> ${escapeHTML(q.Question)}</p>
              
              <div class="options" style="margin: 10px 0;">
                <p><strong>A:</strong> ${escapeHTML(q.A)} ${correctAnswer === 'A' ? '<span style="color: green; font-weight: bold;">(Correct)</span>' : ''}</p>
                <p><strong>B:</strong> ${escapeHTML(q.B)} ${correctAnswer === 'B' ? '<span style="color: green; font-weight: bold;">(Correct)</span>' : ''}</p>
                <p><strong>C:</strong> ${escapeHTML(q.C)} ${correctAnswer === 'C' ? '<span style="color: green; font-weight: bold;">(Correct)</span>' : ''}</p>
                <p><strong>D:</strong> ${escapeHTML(q.D)} ${correctAnswer === 'D' ? '<span style="color: green; font-weight: bold;">(Correct)</span>' : ''}</p>
              </div>
              
              <div class="answer-review" style="margin-top: 10px; padding: 10px; background-color: ${isCorrect ? 'rgba(0,255,0,0.1)' : 'rgba(255,0,0,0.1)'}; border-radius: 5px;">
                <p><strong>Your answer:</strong> ${userAnswer} ${isCorrect ? '<span style="color: green;">(Correct)</span>' : '<span style="color: red;">(Incorrect)</span>'}</p>
                <p><strong>Correct answer:</strong> ${correctAnswer}</p>
                <p><strong>Explanation:</strong> ${escapeHTML(q.Explanation)}</p>
              </div>
              
              <div class="metadata" style="margin-top: 10px; font-size: 0.9em; color: #666;">
                <p><strong>Subtopic:</strong> ${escapeHTML(q.Subtopic || "Not specified")}</p>
                <p><strong>Microtopic:</strong> ${escapeHTML(q.Microtopic || "Not specified")}</p>
              </div>
            </div>
          `;
        });
        
        document.getElementById("review").innerHTML = reviewHTML;
        
        const currentExam = document.getElementById("testletTitle").textContent;
        const quizType = "MCQ";
        let resultsString = currentExam + ";" + quizType + ";";
        Object.keys(breakdown).forEach(sub => {
          resultsString += "sub;" + sub + ";" + breakdown[sub].correct + ";" + breakdown[sub].total + ";";
        });
        Object.keys(microBreakdown).forEach(mt => {
          let parentSub = "Unknown";
          if (taxonomyData.microToSub[currentExam] && taxonomyData.microToSub[currentExam][mt]) {
            parentSub = taxonomyData.microToSub[currentExam][mt];
          } else {
            const questionWithTopic = quizQuestions.find(q => 
              q.Microtopic && q.Microtopic.trim() === mt && 
              q.Subtopic && q.Subtopic.trim() !== ""
            );
            if (questionWithTopic) {
              parentSub = questionWithTopic.Subtopic.trim();
            }
          }
          resultsString += "micro;" + mt + ";" + microBreakdown[mt].correct + ";" + microBreakdown[mt].total + ";" + parentSub + ";";
        });
        window.quizData = {
          exam: document.getElementById("testletTitle").textContent,
          subtopics: document.getElementById("subtopicDisplay").textContent,
          microtopics: "Various",
          numQuestions: total,
          correctAnswers: correctCount,
          percentage: percent,
          resultsString: resultsString
        };
        try {
          const microtopicSelect = document.getElementById("microtopicSelect");
          if (microtopicSelect && microtopicSelect.selectedOptions && microtopicSelect.selectedOptions.length > 0) {
            window.quizData.microtopics = Array.from(microtopicSelect.selectedOptions)
              .map(opt => opt.value)
              .join(", ");
          }
        } catch (e) {
          console.error("Error getting microtopics:", e);
        }
        console.log("Quiz data prepared:", window.quizData);
        logCompleteQuizData(correctCount, total, percent);
      }
      function logCompleteQuizData(correctCount, totalQuestions, percentage) {
        console.log("Logging complete quiz data...");
        const quizData = window.quizData || {
          exam: "Unknown",
          subtopics: "Unknown",
          microtopics: "Unknown",
          numQuestions: totalQuestions,
          resultsString: ""
        };
        
        // Get the SiteUserInfo cookie instead of IP address
        let siteUserId = "Unknown";
        const siteUserInfoCookie = document.cookie.split('; ').find(row => row.startsWith('SiteUserInfo='));
        if (siteUserInfoCookie) {
          try {
            const decodedCookie = decodeURIComponent(siteUserInfoCookie.split('=')[1]);
            const userInfo = JSON.parse(decodedCookie);
            if (userInfo && userInfo.siteUserId) {
              siteUserId = userInfo.siteUserId;
            }
          } catch (err) {
            console.error("Error parsing SiteUserInfo cookie:", err);
          }
        }
        
        const logData = {
          ip: siteUserId, // Using siteUserId instead of IP
          timestamp: new Date().toISOString(),
          exam: quizData.exam,
          subtopics: quizData.subtopics,
          microtopics: quizData.microtopics,
          numQuestions: totalQuestions.toString(),
          correctAnswers: correctCount.toString(),
          percentage: percentage + "%",
          sourceUrl: window.location.href,
          resultsString: quizData.resultsString
        };
        
        console.log("Sending complete quiz data:", logData);
        fetch('https://script.google.com/macros/s/AKfycbxiinfolz65zvpjx3w15rsoA1SltnfYA3Pq3sdoMCAEgzbXHweta-Uld1KXVeaTQOr1Eg/exec', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(logData),
          mode: 'no-cors'
        })
        .then(response => {
          console.log('Quiz data with score sent successfully');
        })
        .catch(error => {
          console.error('Error logging quiz data:', error);
        });
      }
      function retakeQuiz() {
        currentQuestionIndex = 0;
        userAnswers = [];
        quizQuestions.forEach(q => q.userAnswer = "");
        populateQuestionDropdown();
        document.getElementById("results").style.display = "none";
        document.getElementById("testletContainer").style.display = "block";
        showQuestion(0);
        updateProgressBar();
        window.scrollTo(0, 0);
      }
      function stopQuestionTimer() {
        if (questionTimer) {
          clearInterval(questionTimer);
          questionTimer = null;
        }
      }
      function shuffleArray(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
      }
      function escapeHTML(str) {
        if (!str) return "";
        return str.replace(/&/g, "&amp;")
                  .replace(/</g, "&lt;")
                  .replace(/>/g, "&gt;")
                  .replace(/\r?\n/g, "<br>");
      }
      function toggleCalculator() {
        const popup = document.getElementById("calculatorPopup");
        if (popup.style.display === "none" || popup.style.display === "") {
          popup.style.display = "block";
          updateCalcDisplay();
          setTimeout(() => { document.addEventListener("click", handleClickOutsideCalculator); }, 0);
        } else {
          popup.style.display = "none";
          document.removeEventListener("click", handleClickOutsideCalculator);
        }
      }
      function handleClickOutsideCalculator(e) {
        const popup = document.getElementById("calculatorPopup");
        if (!popup.contains(e.target) && e.target.id !== "calcBtn") {
          popup.style.display = "none";
          document.removeEventListener("click", handleClickOutsideCalculator);
        }
      }
      function updateCalcDisplay() {
        document.getElementById("calcDisplay").textContent = calcExpression === "" ? "0" : calcExpression;
      }
      function performEquals() {
        try {
          let result = eval(calcExpression);
          document.getElementById("calcDisplay").textContent = result;
          calcExpression = String(result);
        } catch (err) {
          document.getElementById("calcDisplay").textContent = "Error";
          calcExpression = "";
        }
      }
      function initCalculator() {
        const btnContainer = document.getElementById("calcButtons");
        btnContainer.addEventListener("click", (e) => {
          if (e.target.tagName.toLowerCase() !== "button") return;
          const action = e.target.getAttribute("data-action");
          const value = e.target.getAttribute("data-value");
          if (action === "clear") {
            calcExpression = "";
            updateCalcDisplay();
          } else if (action === "equals") {
            performEquals();
          } else if (action === "square") {
            try {
              let num = eval(calcExpression);
              calcExpression = String(num * num);
              updateCalcDisplay();
            } catch (err) {
              calcExpression = "";
              updateCalcDisplay();
            }
          } else if (action === "sqrt") {
            try {
              let num = eval(calcExpression);
              calcExpression = num < 0 ? "Error" : String(Math.sqrt(num));
              updateCalcDisplay();
            } catch (err) {
              calcExpression = "";
              updateCalcDisplay();
            }
          } else if (value !== null) {
            calcExpression += value;
            updateCalcDisplay();
          }
        });
      }
      function initCalculatorDrag() {
        const popup = document.getElementById("calculatorPopup");
        const dragBar = document.getElementById("calcDragBar");
        let offsetX = 0, offsetY = 0, isDragging = false;
        dragBar.addEventListener("mousedown", function(e) {
          if(popup.style.transform !== "none") {
            let rect = popup.getBoundingClientRect();
            popup.style.left = rect.left + "px";
            popup.style.top = rect.top + "px";
            popup.style.transform = "none";
          }
          isDragging = true;
          offsetX = e.clientX - popup.offsetLeft;
          offsetY = e.clientY - popup.offsetTop;
          document.addEventListener("mousemove", movePopup);
          document.addEventListener("mouseup", function() {
            isDragging = false;
            document.removeEventListener("mousemove", movePopup);
          }, { once: true });
        });
        function movePopup(e) {
          if (!isDragging) return;
          popup.style.left = (e.clientX - offsetX) + "px";
          popup.style.top = (e.clientY - offsetY) + "px";
          popup.style.transform = "none";
        }
      }
      function initHelpDrag() {
        const helpPopup = document.getElementById("helpPopup");
        const helpHeader = document.getElementById("helpPopupHeader");
        let offsetX = 0, offsetY = 0, isDragging = false;
        helpHeader.addEventListener("mousedown", function(e) {
          if (helpPopup.style.transform !== "none") {
            let rect = helpPopup.getBoundingClientRect();
            helpPopup.style.left = rect.left + "px";
            helpPopup.style.top = rect.top + "px";
            helpPopup.style.transform = "none";
          }
          isDragging = true;
          offsetX = e.clientX - helpPopup.offsetLeft;
          offsetY = e.clientY - helpPopup.offsetTop;
          document.addEventListener("mousemove", moveHelpPopup);
          document.addEventListener("mouseup", function() {
            isDragging = false;
            document.removeEventListener("mousemove", moveHelpPopup);
          }, { once: true });
        });
        function moveHelpPopup(e) {
          if (!isDragging) return;
          helpPopup.style.left = (e.clientX - offsetX) + "px";
          helpPopup.style.top = (e.clientY - offsetY) + "px";
          helpPopup.style.transform = "none";
        }
      }
      function initHintDrag() {
        const hintPopup = document.getElementById("hintPopup");
        const hintDragBar = document.getElementById("hintDragBar");
        let offsetX = 0, offsetY = 0, isDragging = false;
        hintDragBar.addEventListener("mousedown", function(e) {
          if (hintPopup.style.transform !== "none") {
            let rect = hintPopup.getBoundingClientRect();
            hintPopup.style.left = rect.left + "px";
            hintPopup.style.top = rect.top + "px";
            hintPopup.style.transform = "none";
          }
          isDragging = true;
          offsetX = e.clientX - hintPopup.offsetLeft;
          offsetY = e.clientY - hintPopup.offsetTop;
          document.addEventListener("mousemove", moveHintPopup);
          document.addEventListener("mouseup", function() {
            isDragging = false;
            document.removeEventListener("mousemove", moveHintPopup);
          }, { once: true });
        });
        function moveHintPopup(e) {
          if (!isDragging) return;
          hintPopup.style.left = (e.clientX - offsetX) + "px";
          hintPopup.style.top = (e.clientY - offsetY) + "px";
          hintPopup.style.transform = "none";
        }
      }
      function initHistoricalScoresDrag() {
        const popup = document.getElementById("historicalScoresPopup");
        const header = document.getElementById("historicalScoresHeader");
        let offsetX = 0, offsetY = 0, isDragging = false;
        header.addEventListener("mousedown", function(e) {
          if (popup.style.transform !== "none") {
            let rect = popup.getBoundingClientRect();
            popup.style.left = rect.left + "px";
            popup.style.top = rect.top + "px";
            popup.style.transform = "none";
          }
          isDragging = true;
          offsetX = e.clientX - popup.offsetLeft;
          offsetY = e.clientY - popup.offsetTop;
          document.addEventListener("mousemove", movePopup);
          document.addEventListener("mouseup", function() {
            isDragging = false;
            document.removeEventListener("mousemove", movePopup);
          }, { once: true });
        });
        function movePopup(e) {
          if (!isDragging) return;
          popup.style.left = (e.clientX - offsetX) + "px";
          popup.style.top = (e.clientY - offsetY) + "px";
          popup.style.transform = "none";
        }
      }
      function togglePause() {
        const pauseBtn = document.getElementById("pauseBtn");
        isPaused = !isPaused;
        if (isPaused) {
          pauseBtn.innerHTML = "&#9658;"; // play symbol
        } else {
          pauseBtn.innerHTML = "&#10073;&#10073;"; // pause symbol
        }
      }
      function openHelpPopup() {
        const qData = quizQuestions[currentQuestionIndex];
        const micro = qData.Microtopic ? qData.Microtopic.trim() : "";
        let helpItem = helpCSVData.find(item => item.microtopic && item.microtopic.trim().toLowerCase() === micro.toLowerCase());
        let helpContent = "";
        if (helpItem && helpItem.html) {
          helpContent = helpItem.html;
        } else {
          helpContent = "<p style='padding: 0 5px;'>No help available for this question.</p>";
        }
        document.getElementById("helpIframe").srcdoc = helpContent;
        document.getElementById("helpOverlay").style.display = "block";
      }
      function closeHelpPopup() {
        document.getElementById("helpOverlay").style.display = "none";
      }
      function openHintPopup() {
        const qData = quizQuestions[currentQuestionIndex];
        if (qData.Hint && qData.Hint.trim() !== "") {
          document.getElementById("hintContent").innerHTML = qData.Hint;
          document.getElementById("hintPopup").style.display = "block";
          setTimeout(() => {
            document.addEventListener("click", handleClickOutsideHint);
          }, 0);
        }
      }
      function handleClickOutsideHint(e) {
        const popup = document.getElementById("hintPopup");
        if (!popup.contains(e.target) && e.target.id !== "hintBtn") {
          popup.style.display = "none";
          document.removeEventListener("click", handleClickOutsideHint);
        }
      }
      function closeHintPopup() {
        document.getElementById("hintPopup").style.display = "none";
        document.removeEventListener("click", handleClickOutsideHint);
      }
      function openHistoricalScoresPopup() {
        document.getElementById("historicalScoresContent").innerHTML = '<div class="history-loading">Loading historical scores...</div>';
        document.getElementById("historicalScoresOverlay").style.display = "block";
        fetchHistoricalScores();
      }
      function closeHistoricalScoresPopup() {
        document.getElementById("historicalScoresOverlay").style.display = "none";
      }
      function fetchHistoricalScores() {
        const currentExam = document.getElementById("testletTitle").textContent;
        
        // Get the SiteUserInfo cookie instead of IP address
        let siteUserId = "Unknown";
        const siteUserInfoCookie = document.cookie.split('; ').find(row => row.startsWith('SiteUserInfo='));
        if (siteUserInfoCookie) {
          try {
            const decodedCookie = decodeURIComponent(siteUserInfoCookie.split('=')[1]);
            const userInfo = JSON.parse(decodedCookie);
            if (userInfo && userInfo.siteUserId) {
              siteUserId = userInfo.siteUserId;
            }
          } catch (err) {
            console.error("Error parsing SiteUserInfo cookie:", err);
          }
        }
        
        const apiUrl = 'https://script.google.com/macros/s/AKfycbxiinfolz65zvpjx3w15rsoA1SltnfYA3Pq3sdoMCAEgzbXHweta-Uld1KXVeaTQOr1Eg/exec';
        const callbackName = 'historicalScoresCallback_' + Math.random().toString(36).substr(2, 9);
        window[callbackName] = function(data) {
          processHistoricalScores(data, currentExam);
          const scriptElement = document.getElementById('jsonp-script');
          if (scriptElement) document.head.removeChild(scriptElement);
          delete window[callbackName];
        };
        
        const script = document.createElement('script');
        script.id = 'jsonp-script';
        script.src = `${apiUrl}?ip=${siteUserId}&exam=${currentExam}&callback=${callbackName}`;
        script.onerror = function() {
          document.getElementById("historicalScoresContent").innerHTML = 
            '<div class="history-error">Error fetching historical scores. Please try again later.</div>';
          delete window[callbackName];
        };
        document.head.appendChild(script);
      }
      function processHistoricalScores(data, currentExam) {
        const content = document.getElementById("historicalScoresContent");
        if (!data || data.error) {
          content.innerHTML = `<div class="history-error">${data.error || 'Error retrieving historical scores'}</div>`;
          return;
        }
        const parsedResults = parseHistoricalResults(data.results, currentExam);
        if (taxonomyData.subtopics[currentExam]) {
          taxonomyData.subtopics[currentExam].forEach(subtopic => {
            if (!parsedResults.subtopics[subtopic]) {
              parsedResults.subtopics[subtopic] = {
                totalCorrect: 0,
                totalQuestions: 0
              };
            }
            if (taxonomyData.microtopics && taxonomyData.microtopics[currentExam] && 
                taxonomyData.microtopics[currentExam][subtopic]) {
              taxonomyData.microtopics[currentExam][subtopic].forEach(microtopic => {
                if (!parsedResults.microtopics[microtopic]) {
                  parsedResults.microtopics[microtopic] = {
                    totalCorrect: 0,
                    totalQuestions: 0,
                    parentSubtopic: subtopic
                  };
                }
              });
            }
          });
        }
        let html = `<h3>Your Historical ${currentExam} Scores</h3>`;
        html += '<h4>Overall Stats</h4>';
        let overallCorrect = 0;
        let overallTotal = 0;
        for (const subtopic in parsedResults.subtopics) {
          overallCorrect += parsedResults.subtopics[subtopic].totalCorrect;
          overallTotal += parsedResults.subtopics[subtopic].totalQuestions;
        }
        const overallPercentCorrect = (overallTotal > 0) ? 
          (overallCorrect / overallTotal * 100).toFixed(1) : "0.0";
        const totalQuizzes = parsedResults.totalQuizzes || 0;
        html += `<p>Total Quizzes: ${totalQuizzes}</p>`;
        html += `<p>Total Correct: ${overallCorrect}</p>`;
        html += `<p>Total Attempted: ${overallTotal}</p>`;
        html += `<p>% Correct: ${overallPercentCorrect}%</p>`;
        const subtopicArray = [];
        for (const subtopic in parsedResults.subtopics) {
          subtopicArray.push(subtopic);
        }
        subtopicArray.sort();
        if (subtopicArray.length > 0) {
          html += '<h4>Subtopics Performance</h4>';
          html += '<table class="history-table">';
          html += '<tr><th>Subtopic</th><th>Total Correct</th><th>Total Attempted</th><th>% Correct</th></tr>';
          for (const subtopic of subtopicArray) {
            const data = parsedResults.subtopics[subtopic];
            const percentCorrect = (data.totalQuestions > 0) ? 
              (data.totalCorrect / data.totalQuestions * 100).toFixed(1) : "0.0";
            html += `<tr>
              <td>${subtopic}</td>
              <td>${data.totalCorrect}</td>
              <td>${data.totalQuestions}</td>
              <td>${percentCorrect}%</td>
            </tr>`;
          }
          html += '</table>';
        }
        const allMicrotopics = [];
        const unattemptedMicrotopics = [];
        for (const microtopic in parsedResults.microtopics) {
          const microData = parsedResults.microtopics[microtopic];
          allMicrotopics.push({
            name: microtopic,
            data: microData
          });
          if (microData.totalQuestions === 0) {
            unattemptedMicrotopics.push({
              name: microtopic,
              parentSubtopic: microData.parentSubtopic || "Unknown"
            });
          }
        }
        allMicrotopics.sort((a, b) => {
          const parentA = a.data.parentSubtopic || "Unknown";
          const parentB = b.data.parentSubtopic || "Unknown";
          if (parentA !== parentB) {
            return parentA.localeCompare(parentB);
          }
          return a.name.localeCompare(b.name);
        });
        if (allMicrotopics.length > 0) {
          html += '<h4>Microtopics Performance</h4>';
          html += '<table class="history-table">';
          html += '<tr><th>Microtopic</th><th>Subtopic</th><th>Total Correct</th><th>Total Attempted</th><th>% Correct</th></tr>';
          for (const item of allMicrotopics) {
            const microtopic = item.name;
            const data = item.data;
            const parentSubtopic = data.parentSubtopic || "Unknown";
            const percentCorrect = (data.totalQuestions > 0) ? 
              (data.totalCorrect / data.totalQuestions * 100).toFixed(1) : "0.0";
            html += `<tr>
              <td>${microtopic}</td>
              <td>${parentSubtopic}</td>
              <td>${data.totalCorrect}</td>
              <td>${data.totalQuestions}</td>
              <td>${percentCorrect}%</td>
            </tr>`;
          }
          html += '</table>';
        }
        if (unattemptedMicrotopics.length > 0) {
          unattemptedMicrotopics.sort((a, b) => {
            if (a.parentSubtopic !== b.parentSubtopic) {
              return a.parentSubtopic.localeCompare(b.parentSubtopic);
            }
            return a.name.localeCompare(b.name);
          });
          const bySubtopic = {};
          unattemptedMicrotopics.forEach(item => {
            if (!bySubtopic[item.parentSubtopic]) {
              bySubtopic[item.parentSubtopic] = [];
            }
            bySubtopic[item.parentSubtopic].push(item.name);
          });
          html += '<h4>Topics Not Yet Attempted</h4>';
          html += '<div class="unattempted-section">';
          Object.keys(bySubtopic).sort().forEach(subtopic => {
            html += `<div class="unattempted-group">
              <h5>${subtopic}</h5>
              <ul>`;
            bySubtopic[subtopic].forEach(microtopic => {
              html += `<li>${microtopic}</li>`;
            });
            html += `</ul>
            </div>`;
          });
          html += '</div>';
        }
        content.innerHTML = html;
      }
      function parseHistoricalResults(resultsArray, currentExam) {
        const subtopics = {};
        const microtopics = {};
        let totalQuizzes = 0;
        if (taxonomyData.subtopics[currentExam]) {
          taxonomyData.subtopics[currentExam].forEach(subtopic => {
            subtopics[subtopic] = {
              totalCorrect: 0,
              totalQuestions: 0
            };
          });
        }
        resultsArray.forEach(resultString => {
          if (!resultString) return;
          const parts = resultString.split(';');
          const exam = parts[0];
          const quizType = parts[1];
          if (quizType !== "MCQ") return;
          let i = 2;
          if (exam !== currentExam) return;
          totalQuizzes++;
          while (i < parts.length - 1) {
            if (parts[i] === "sub" || parts[i] === "micro") {
              const type = parts[i];
              const topic = parts[i + 1] || "";
              const correct = parseInt(parts[i + 2], 10) || 0;
              const total = parseInt(parts[i + 3], 10) || 0;
              if (!topic || isNaN(correct) || isNaN(total)) {
                i += (type === "micro" ? 5 : 4);
                continue;
              }
              if (type === "sub") {
                if (!subtopics[topic]) {
                  subtopics[topic] = {
                    totalCorrect: 0,
                    totalQuestions: 0
                  };
                }
                subtopics[topic].totalCorrect += correct;
                subtopics[topic].totalQuestions += total;
                i += 4;
              } else if (type === "micro") {
                const parentSub = parts[i + 4] || "Unknown";
                if (!microtopics[topic]) {
                  microtopics[topic] = {
                    totalCorrect: 0,
                    totalQuestions: 0,
                    parentSubtopic: parentSub
                  };
                }
                microtopics[topic].totalCorrect += correct;
                microtopics[topic].totalQuestions += total;
                i += 5;
              }
            } else {
              const topic = parts[i] || "";
              const correct = parseInt(parts[i + 1], 10) || 0;
              const total = parseInt(parts[i + 2], 10) || 0;
              if (!topic || isNaN(correct) || isNaN(total)) {
                i += 3;
                continue;
              }
              const isSubtopic = i < parts.length / 2;
              if (isSubtopic) {
                if (!subtopics[topic]) {
                  subtopics[topic] = {
                    totalCorrect: 0,
                    totalQuestions: 0
                  };
                }
                subtopics[topic].totalCorrect += correct;
                subtopics[topic].totalQuestions += total;
              } else {
                let parentSubtopic = "Unknown";
                if (taxonomyData.microToSub[currentExam] && taxonomyData.microToSub[currentExam][topic]) {
                  parentSubtopic = taxonomyData.microToSub[currentExam][topic];
                }
                if (!microtopics[topic]) {
                  microtopics[topic] = {
                    totalCorrect: 0,
                    totalQuestions: 0,
                    parentSubtopic: parentSubtopic
                  };
                }
                microtopics[topic].totalCorrect += correct;
                microtopics[topic].totalQuestions += total;
              }
              i += 3;
            }
          }
        });
        Object.keys(microtopics).forEach(microtopic => {
          if (microtopics[microtopic].parentSubtopic === "Unknown" && 
              taxonomyData.microToSub[currentExam] && 
              taxonomyData.microToSub[currentExam][microtopic]) {
            microtopics[microtopic].parentSubtopic = taxonomyData.microToSub[currentExam][microtopic];
          }
        });
        return {
          subtopics,
          microtopics,
          totalQuizzes
        };
      }
      function generateSessionId() {
        return 'quiz-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
      }
      function loadTaxonomyData() {
        console.log("Loading taxonomy data...");
        fetch(taxonomyCSVUrl)
          .then(response => response.text())
          .then(csv => {
            parseTaxonomyCSV(csv);
            console.log("Taxonomy data loaded successfully");
          })
          .catch(error => {
            console.error("Error loading taxonomy data:", error);
          });
      }
      function parseTaxonomyCSV(csv) {
        const lines = csv.split('\n');
        for (let i = 1; i < lines.length; i++) {
          const line = lines[i].trim();
          if (!line) continue;
          const values = parseCSVLine(line);
          if (values.length < 3) continue;
          const exam = values[0].trim();
          const subtopic = values[1].trim();
          const microtopic = values[2].trim();
          if (!exam || !subtopic) continue;
          if (!taxonomyData.subtopics[exam]) {
            taxonomyData.subtopics[exam] = [];
            taxonomyData.microtopics[exam] = {};
            taxonomyData.microToSub[exam] = {};
          }
          if (subtopic && !taxonomyData.subtopics[exam].includes(subtopic)) {
            taxonomyData.subtopics[exam].push(subtopic);
          }
          if (subtopic && !taxonomyData.microtopics[exam][subtopic]) {
            taxonomyData.microtopics[exam][subtopic] = [];
          }
          if (microtopic && subtopic && !taxonomyData.microtopics[exam][subtopic].includes(microtopic)) {
            taxonomyData.microtopics[exam][subtopic].push(microtopic);
            taxonomyData.microToSub[exam][microtopic] = subtopic;
          }
        }
        console.log("Parsed taxonomy data:", taxonomyData);
      }
      function parseCSVLine(line) {
        const result = [];
        let currentValue = "";
        let inQuotes = false;
        for (let i = 0; i < line.length; i++) {
          const char = line[i];
          if (char === '"') {
            inQuotes = !inQuotes;
          } else if (char === ',' && !inQuotes) {
            result.push(currentValue);
            currentValue = "";
          } else {
            currentValue += char;
          }
        }
        result.push(currentValue);
        return result;
      }
    </script>
    <script>
      loadTaxonomyData();
    </script>
  </body>
</html>
